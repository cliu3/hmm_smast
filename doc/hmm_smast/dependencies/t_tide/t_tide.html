<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of t_tide</title>
  <meta name="keywords" content="t_tide">
  <meta name="description" content="T_TIDE Harmonic analysis of a time series">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../../index.html">Home</a> &gt;  <a href="#">hmm_smast</a> &gt; <a href="#">dependencies</a> &gt; <a href="index.html">t_tide</a> &gt; t_tide.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../../index.html"><img alt="<" border="0" src="../../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for hmm_smast/dependencies/t_tide&nbsp;<img alt=">" border="0" src="../../../right.png"></a></td></tr></table>-->

<h1>t_tide
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>T_TIDE Harmonic analysis of a time series</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="box"><strong>function [nameu,fu,tidecon,xout]=t_tide(xin,varargin); </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> T_TIDE Harmonic analysis of a time series
 [NAME,FREQ,TIDECON,XOUT]=T_TIDE(XIN) computes the tidal analysis 
 of the (possibly complex) time series XIN.

 [TIDESTRUC,XOUT]=T_TIDE(XIN) returns the analysis information in
 a structure formed of NAME, FREQ, and TIDECON.

 XIN can be scalar (e.g. for elevations), or complex ( =U+sqrt(-1)*V
 for eastward velocity U and northward velocity V.

 Further inputs are optional, and are specified as property/value pairs
 [...]=T_TIDE(XIN,property,value,property,value,...,etc.)
      
 These properties are:

       'interval'       Sampling interval (hours), default = 1. 
          
   The next two are required if nodal corrections are to be computed,
   otherwise not necessary. If they are not included then the reported
   phases are raw constituent phases at the central time. 

   If your time series is longer than 18.6 years then nodal corrections
   are not made -instead we fit directly to all satellites (start time
   is then just used to generate Greenwich phases).

       'start time'     [year,month,day,hour,min,sec]
                        - min,sec are optional OR 
                        decimal day (matlab DATENUM scalar)
       'latitude'       decimal degrees (+north) (default: none).

   Where to send the output.
       'output'         where to send printed output:
                        'none'    (no printed output)
                        'screen'  (to screen) - default
                        FILENAME   (to a file)

   Correction factor for prefiltering.
       'prefilt'        FS,CORR
                        If the time series has been passed through
                        a pre-filter of some kind (say, to reduce the
                        low-frequency variability), then the analyzed
                        constituents will have to be corrected for 
                        this. The correction transfer function 
                        (1/filter transfer function) has (possibly 
                        complex) magnitude CORR at frequency FS (cph). 
                        Corrections of more than a factor of 100 are 
                        not applied; it is assumed these refer to tidal
                        constituents that were intentionally filtered 
                        out, e.g., the fortnightly components.

   Adjustment for long-term behavior (&quot;secular&quot; behavior).
       'secular'        'mean'   - assume constant offset (default).
                        'linear' - get linear trend.
                     
   Inference of constituents.
       'inference'      NAME,REFERENCE,AMPRAT,PHASE_OFFSET
                        where NAME is an array of the names of 
                        constituents to be inferred, REFERENCE is an 
                        array of the names of references, and AMPRAT 
                        and PHASE_OFFSET are the amplitude factor and
                        phase offset (in degrees)from the references. 
                        NAME and REFERENCE are Nx4 (max 4 characters
                        in name), and AMPRAT and PHASE_OFFSET are Nx1
                        (for scalar time series) and Nx2 for vector 
                        time series (column 1 is for + frequencies and
                        column 2 for - frequencies).
                        NB - you can only infer ONE unknown constituent
                        per known constituent (i.e. REFERENCE must not 
                        contain multiple instances of the same name).

   Shallow water constituents
       'shallow'        NAME
                        A matrix whose rows contain the names of 
                        shallow-water constituents to analyze.

   Resolution criterions for least-squares fit.        
       'rayleigh'       scalar - Rayleigh criteria, default = 1.
                        Matrix of strings - names of constituents to
                                   use (useful for testing purposes).
  
   Calculation of confidence limits.
       'error'          'wboot'  - Boostrapped confidence intervals 
                                   based on a correlated bivariate 
                                   white-noise model.
                        'cboot'  - Boostrapped confidence intervals 
                                   based on an uncorrelated bivariate 
                                   coloured-noise model (default).
                        'linear' - Linearized error analysis that 
                                   assumes an uncorrelated bivariate 
                                   coloured noise model. 
                                   
   Computation of &quot;predicted&quot; tide (passed to t_predic, but note that
                                    the default value is different).
       'synthesis'      0 - use all selected constituents
                        scalar&gt;0 - use only those constituents with a 
                                   SNR greater than that given (1 or 2 
                                   are good choices, 2 is the default).
                              &lt;0 - return result of least-squares fit 
                                   (should be the same as using '0', 
                                   except that NaN-holes in original 
                                   time series will remain and mean/trend
                                   are included).

   Least squares soln computational efficiency parameter
    'lsq'        'direct'  - use A\x fit
            'normal'  - use (A'A)\(A'x) (may be necessary
                    for very large input vectors since
                                   A'A is much smaller than A)
            'best'      - automatically choose based on
                    length of series (default).

       It is possible to call t_tide without using property names,
       in which case the assumed calling sequence is

          T_TIDE(XIN,INTERVAL,START_TIME,LATITUDE,RAYLEIGH)


  OUTPUT: 

    nameu=list of constituents used
    fu=frequency of tidal constituents (cycles/hr)
    tidecon=[fmaj,emaj,fmin,emin,finc,einc,pha,epha] for vector xin
           =[fmaj,emaj,pha,epha] for scalar (real) xin
       fmaj,fmin - constituent major and minor axes (same units as xin)       
       emaj,emin - 95% confidence intervals for fmaj,fmin
       finc - ellipse orientations (degrees)
       einc - 95% confidence intervals for finc
       pha - constituent phases (degrees relative to Greenwich)
       epha - 95% confidence intervals for pha
    xout=tidal prediction

 Note: Although missing data can be handled with NaN, it is wise not
       to have too many of them. If your time series has a lot of 
       missing data at the beginning and/or end, then truncate the 
       input time series.  The Rayleigh criterion is applied to 
       frequency intervals calculated as the inverse of the input 
       series length.

 A description of the theoretical basis of the analysis and some
 implementation details can be found in:

 Pawlowicz, R., B. Beardsley, and S. Lentz, &quot;Classical Tidal 
   &quot;Harmonic Analysis Including Error Estimates in MATLAB 
    using T_TIDE&quot;, Computers and Geosciences, 28, 929-937 (2002).

 (citation of this article would be appreciated if you find the
  toolbox useful).</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="t_getconsts.html" class="code" title="function [const,sat,shallow]=t_getconsts(ctime);">t_getconsts</a>	T_GETCONSTS Gets constituent data structures</li><li><a href="t_predic.html" class="code" title="function yout=t_predic(tim,varargin);">t_predic</a>	T_PREDIC Tidal prediction</li><li><a href="t_vuf.html" class="code" title="function [v,u,f]=t_vuf(ltype,ctime,ju,lat);">t_vuf</a>	T_VUF Computes nodal modulation corrections.</li></ul>
This function is called by:
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="t_demo.html" class="code" title="">t_demo</a>	T_DEMO - demonstration of capabilities.</li><li><a href="t_synth.html" class="code" title="function [sm,lm,tcon]=t_synth(varargin)">t_synth</a>	T_SYNTH Monte-Carlo test of the error estimation using synthetic data</li><li><a href="../../../hmm_smast/test/preprocessing/wrap_ttide_harmonics.html" class="code" title="function [amp,phase] = wrap_ttide_harmonics(eta,dt_minutes,start_time)">wrap_ttide_harmonics</a>	given elevation and time step, calculate harmonics for the folloing comps</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<ul style="list-style-image:url(../../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [nameu,fu,ju,namei,fi,jinf,jref]=constituents(minres,constit,</a></li><li><a href="#_sub2" class="code">function y=fixgaps(x);</a></li><li><a href="#_sub3" class="code">function ain=cluster(ain,clusang);</a></li><li><a href="#_sub4" class="code">function [NP,NM]=noise_realizations(xres,fu,dt,nreal,errcalc);</a></li><li><a href="#_sub5" class="code">function [ercx,eicx]=noise_stats(xres,fu,dt);</a></li><li><a href="#_sub6" class="code">function [fband,Pxrave,Pxiave,Pxcave]=residual_spectrum(xres,fu,dt)</a></li><li><a href="#_sub7" class="code">function [emaj,emin,einc,epha]=errell(cxi,sxi,ercx,ersx,ercy,ersy)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [nameu,fu,tidecon,xout]=t_tide(xin,varargin);</a>
0002 <span class="comment">% T_TIDE Harmonic analysis of a time series</span>
0003 <span class="comment">% [NAME,FREQ,TIDECON,XOUT]=T_TIDE(XIN) computes the tidal analysis</span>
0004 <span class="comment">% of the (possibly complex) time series XIN.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% [TIDESTRUC,XOUT]=T_TIDE(XIN) returns the analysis information in</span>
0007 <span class="comment">% a structure formed of NAME, FREQ, and TIDECON.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% XIN can be scalar (e.g. for elevations), or complex ( =U+sqrt(-1)*V</span>
0010 <span class="comment">% for eastward velocity U and northward velocity V.</span>
0011 <span class="comment">%</span>
0012 <span class="comment">% Further inputs are optional, and are specified as property/value pairs</span>
0013 <span class="comment">% [...]=T_TIDE(XIN,property,value,property,value,...,etc.)</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% These properties are:</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%       'interval'       Sampling interval (hours), default = 1.</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%   The next two are required if nodal corrections are to be computed,</span>
0020 <span class="comment">%   otherwise not necessary. If they are not included then the reported</span>
0021 <span class="comment">%   phases are raw constituent phases at the central time.</span>
0022 <span class="comment">%</span>
0023 <span class="comment">%   If your time series is longer than 18.6 years then nodal corrections</span>
0024 <span class="comment">%   are not made -instead we fit directly to all satellites (start time</span>
0025 <span class="comment">%   is then just used to generate Greenwich phases).</span>
0026 <span class="comment">%</span>
0027 <span class="comment">%       'start time'     [year,month,day,hour,min,sec]</span>
0028 <span class="comment">%                        - min,sec are optional OR</span>
0029 <span class="comment">%                        decimal day (matlab DATENUM scalar)</span>
0030 <span class="comment">%       'latitude'       decimal degrees (+north) (default: none).</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%   Where to send the output.</span>
0033 <span class="comment">%       'output'         where to send printed output:</span>
0034 <span class="comment">%                        'none'    (no printed output)</span>
0035 <span class="comment">%                        'screen'  (to screen) - default</span>
0036 <span class="comment">%                        FILENAME   (to a file)</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%   Correction factor for prefiltering.</span>
0039 <span class="comment">%       'prefilt'        FS,CORR</span>
0040 <span class="comment">%                        If the time series has been passed through</span>
0041 <span class="comment">%                        a pre-filter of some kind (say, to reduce the</span>
0042 <span class="comment">%                        low-frequency variability), then the analyzed</span>
0043 <span class="comment">%                        constituents will have to be corrected for</span>
0044 <span class="comment">%                        this. The correction transfer function</span>
0045 <span class="comment">%                        (1/filter transfer function) has (possibly</span>
0046 <span class="comment">%                        complex) magnitude CORR at frequency FS (cph).</span>
0047 <span class="comment">%                        Corrections of more than a factor of 100 are</span>
0048 <span class="comment">%                        not applied; it is assumed these refer to tidal</span>
0049 <span class="comment">%                        constituents that were intentionally filtered</span>
0050 <span class="comment">%                        out, e.g., the fortnightly components.</span>
0051 <span class="comment">%</span>
0052 <span class="comment">%   Adjustment for long-term behavior (&quot;secular&quot; behavior).</span>
0053 <span class="comment">%       'secular'        'mean'   - assume constant offset (default).</span>
0054 <span class="comment">%                        'linear' - get linear trend.</span>
0055 <span class="comment">%</span>
0056 <span class="comment">%   Inference of constituents.</span>
0057 <span class="comment">%       'inference'      NAME,REFERENCE,AMPRAT,PHASE_OFFSET</span>
0058 <span class="comment">%                        where NAME is an array of the names of</span>
0059 <span class="comment">%                        constituents to be inferred, REFERENCE is an</span>
0060 <span class="comment">%                        array of the names of references, and AMPRAT</span>
0061 <span class="comment">%                        and PHASE_OFFSET are the amplitude factor and</span>
0062 <span class="comment">%                        phase offset (in degrees)from the references.</span>
0063 <span class="comment">%                        NAME and REFERENCE are Nx4 (max 4 characters</span>
0064 <span class="comment">%                        in name), and AMPRAT and PHASE_OFFSET are Nx1</span>
0065 <span class="comment">%                        (for scalar time series) and Nx2 for vector</span>
0066 <span class="comment">%                        time series (column 1 is for + frequencies and</span>
0067 <span class="comment">%                        column 2 for - frequencies).</span>
0068 <span class="comment">%                        NB - you can only infer ONE unknown constituent</span>
0069 <span class="comment">%                        per known constituent (i.e. REFERENCE must not</span>
0070 <span class="comment">%                        contain multiple instances of the same name).</span>
0071 <span class="comment">%</span>
0072 <span class="comment">%   Shallow water constituents</span>
0073 <span class="comment">%       'shallow'        NAME</span>
0074 <span class="comment">%                        A matrix whose rows contain the names of</span>
0075 <span class="comment">%                        shallow-water constituents to analyze.</span>
0076 <span class="comment">%</span>
0077 <span class="comment">%   Resolution criterions for least-squares fit.</span>
0078 <span class="comment">%       'rayleigh'       scalar - Rayleigh criteria, default = 1.</span>
0079 <span class="comment">%                        Matrix of strings - names of constituents to</span>
0080 <span class="comment">%                                   use (useful for testing purposes).</span>
0081 <span class="comment">%</span>
0082 <span class="comment">%   Calculation of confidence limits.</span>
0083 <span class="comment">%       'error'          'wboot'  - Boostrapped confidence intervals</span>
0084 <span class="comment">%                                   based on a correlated bivariate</span>
0085 <span class="comment">%                                   white-noise model.</span>
0086 <span class="comment">%                        'cboot'  - Boostrapped confidence intervals</span>
0087 <span class="comment">%                                   based on an uncorrelated bivariate</span>
0088 <span class="comment">%                                   coloured-noise model (default).</span>
0089 <span class="comment">%                        'linear' - Linearized error analysis that</span>
0090 <span class="comment">%                                   assumes an uncorrelated bivariate</span>
0091 <span class="comment">%                                   coloured noise model.</span>
0092 <span class="comment">%</span>
0093 <span class="comment">%   Computation of &quot;predicted&quot; tide (passed to t_predic, but note that</span>
0094 <span class="comment">%                                    the default value is different).</span>
0095 <span class="comment">%       'synthesis'      0 - use all selected constituents</span>
0096 <span class="comment">%                        scalar&gt;0 - use only those constituents with a</span>
0097 <span class="comment">%                                   SNR greater than that given (1 or 2</span>
0098 <span class="comment">%                                   are good choices, 2 is the default).</span>
0099 <span class="comment">%                              &lt;0 - return result of least-squares fit</span>
0100 <span class="comment">%                                   (should be the same as using '0',</span>
0101 <span class="comment">%                                   except that NaN-holes in original</span>
0102 <span class="comment">%                                   time series will remain and mean/trend</span>
0103 <span class="comment">%                                   are included).</span>
0104 <span class="comment">%</span>
0105 <span class="comment">%   Least squares soln computational efficiency parameter</span>
0106 <span class="comment">%    'lsq'        'direct'  - use A\x fit</span>
0107 <span class="comment">%            'normal'  - use (A'A)\(A'x) (may be necessary</span>
0108 <span class="comment">%                    for very large input vectors since</span>
0109 <span class="comment">%                                   A'A is much smaller than A)</span>
0110 <span class="comment">%            'best'      - automatically choose based on</span>
0111 <span class="comment">%                    length of series (default).</span>
0112 <span class="comment">%</span>
0113 <span class="comment">%       It is possible to call t_tide without using property names,</span>
0114 <span class="comment">%       in which case the assumed calling sequence is</span>
0115 <span class="comment">%</span>
0116 <span class="comment">%          T_TIDE(XIN,INTERVAL,START_TIME,LATITUDE,RAYLEIGH)</span>
0117 <span class="comment">%</span>
0118 <span class="comment">%</span>
0119 <span class="comment">%  OUTPUT:</span>
0120 <span class="comment">%</span>
0121 <span class="comment">%    nameu=list of constituents used</span>
0122 <span class="comment">%    fu=frequency of tidal constituents (cycles/hr)</span>
0123 <span class="comment">%    tidecon=[fmaj,emaj,fmin,emin,finc,einc,pha,epha] for vector xin</span>
0124 <span class="comment">%           =[fmaj,emaj,pha,epha] for scalar (real) xin</span>
0125 <span class="comment">%       fmaj,fmin - constituent major and minor axes (same units as xin)</span>
0126 <span class="comment">%       emaj,emin - 95% confidence intervals for fmaj,fmin</span>
0127 <span class="comment">%       finc - ellipse orientations (degrees)</span>
0128 <span class="comment">%       einc - 95% confidence intervals for finc</span>
0129 <span class="comment">%       pha - constituent phases (degrees relative to Greenwich)</span>
0130 <span class="comment">%       epha - 95% confidence intervals for pha</span>
0131 <span class="comment">%    xout=tidal prediction</span>
0132 <span class="comment">%</span>
0133 <span class="comment">% Note: Although missing data can be handled with NaN, it is wise not</span>
0134 <span class="comment">%       to have too many of them. If your time series has a lot of</span>
0135 <span class="comment">%       missing data at the beginning and/or end, then truncate the</span>
0136 <span class="comment">%       input time series.  The Rayleigh criterion is applied to</span>
0137 <span class="comment">%       frequency intervals calculated as the inverse of the input</span>
0138 <span class="comment">%       series length.</span>
0139 <span class="comment">%</span>
0140 <span class="comment">% A description of the theoretical basis of the analysis and some</span>
0141 <span class="comment">% implementation details can be found in:</span>
0142 <span class="comment">%</span>
0143 <span class="comment">% Pawlowicz, R., B. Beardsley, and S. Lentz, &quot;Classical Tidal</span>
0144 <span class="comment">%   &quot;Harmonic Analysis Including Error Estimates in MATLAB</span>
0145 <span class="comment">%    using T_TIDE&quot;, Computers and Geosciences, 28, 929-937 (2002).</span>
0146 <span class="comment">%</span>
0147 <span class="comment">% (citation of this article would be appreciated if you find the</span>
0148 <span class="comment">%  toolbox useful).</span>
0149 
0150 
0151 <span class="comment">% R. Pawlowicz 11/8/99 - Completely rewritten from the transliterated-</span>
0152 <span class="comment">%                        to-matlab IOS/Foreman fortran code by S. Lentz</span>
0153 <span class="comment">%                        and B. Beardsley.</span>
0154 <span class="comment">%              3/3/00  - Redid errors to take into account covariances</span>
0155 <span class="comment">%                        between u and v errors.</span>
0156 <span class="comment">%              7/21/00 - Found that annoying bug in error calc!</span>
0157 <span class="comment">%              11/1/00 - Added linear error analysis.</span>
0158 <span class="comment">%              8/29/01 - Made synth=1 default, also changed behavior</span>
0159 <span class="comment">%                        when no lat/time given so that phases are raw</span>
0160 <span class="comment">%                        at central time.</span>
0161 <span class="comment">%              9/1/01  - Moved some SNR code to t_predic.</span>
0162 <span class="comment">%              9/28/01 - made sure you can't choose Z0 as constituent.</span>
0163 <span class="comment">%              6/12/01 - better explanation for variance calcs, fixed</span>
0164 <span class="comment">%                        bug in typed output (thanks Mike Cook).</span>
0165 <span class="comment">%              8/2/03 - Added block processing for long time series (thanks</span>
0166 <span class="comment">%                       to Derek Goring).</span>
0167 <span class="comment">%              9/2/03 - Beta version of 18.6 year series handling</span>
0168 <span class="comment">%              12/2/03 - Bug (x should be xin) fixed thanks to Mike Cook (again!)</span>
0169 <span class="comment">%              4/3/11 - Changed (old) psd to (new) pwelch calls, also</span>
0170 <span class="comment">%                       isfinite for finite.</span>
0171 <span class="comment">%              23/3/11 - Corrected my conversion from psd to pwelch, thanks</span>
0172 <span class="comment">%                       to Dan Codiga and (especially) Evan Haug!</span>
0173 
0174 <span class="comment">%</span>
0175 <span class="comment">% Version 1.3</span>
0176 
0177 
0178 
0179 <span class="comment">% ----------------------Parse inputs-----------------------------------</span>
0180 
0181 ray=1;
0182 dt=1;
0183 fid=1;
0184 stime=[];
0185 lat=[];
0186 corr_fs=[0 1e6];
0187 corr_fac=[1  1];
0188 secular=<span class="string">'mean'</span>;
0189 inf.iname=[];
0190 inf.irefname=[];
0191 shallownames=[];
0192 constitnames=[];
0193 errcalc=<span class="string">'cboot'</span>;
0194 synth=2;
0195 lsq=<span class="string">'best'</span>;
0196 
0197 k=1;
0198 <span class="keyword">while</span> length(varargin)&gt;0,
0199   <span class="keyword">if</span> ischar(varargin{1}),
0200     <span class="keyword">switch</span> lower(varargin{1}(1:3)),
0201       <span class="keyword">case</span> <span class="string">'int'</span>,
0202         dt=varargin{2};
0203       <span class="keyword">case</span> <span class="string">'sta'</span>,
0204         stime=varargin{2};
0205     <span class="keyword">if</span> length(stime)&gt;1, 
0206       stime=[stime(:)' zeros(1,6-length(stime))]; 
0207       stime=datenum(stime(1),stime(2),stime(3),stime(4),stime(5),stime(6));
0208     <span class="keyword">end</span>;
0209       <span class="keyword">case</span> <span class="string">'lat'</span>,
0210          lat=varargin{2};
0211       <span class="keyword">case</span> <span class="string">'out'</span>,
0212          filen=varargin{2};
0213      <span class="keyword">switch</span> filen,
0214        <span class="keyword">case</span> <span class="string">'none'</span>,
0215          fid=-1;
0216        <span class="keyword">case</span> <span class="string">'screen'</span>,
0217          fid=1;
0218        <span class="keyword">otherwise</span>
0219          [fid,mesg]=fopen(filen,<span class="string">'w'</span>);
0220          <span class="keyword">if</span> fid==-1, error(msg); <span class="keyword">end</span>;
0221       <span class="keyword">end</span>;
0222       <span class="keyword">case</span> <span class="string">'ray'</span>,
0223          <span class="keyword">if</span> isnumeric(varargin{2}),
0224            ray=varargin{2};
0225      <span class="keyword">else</span>
0226        constitnames=varargin{2};
0227        <span class="keyword">if</span> iscellstr(constitnames), constitnames=char(constitnames); <span class="keyword">end</span>;
0228      <span class="keyword">end</span>;
0229        <span class="keyword">case</span> <span class="string">'pre'</span>,
0230          corr_fs=varargin{2};
0231      corr_fac=varargin{3};
0232          varargin(1)=[];
0233       <span class="keyword">case</span> <span class="string">'sec'</span>,
0234          secular=varargin{2};
0235       <span class="keyword">case</span> <span class="string">'inf'</span>,
0236          inf.iname=varargin{2};
0237      inf.irefname=varargin{3};
0238      inf.amprat=varargin{4};
0239      inf.ph=varargin{5};
0240      varargin(1:3)=[];
0241       <span class="keyword">case</span> <span class="string">'sha'</span>,
0242          shallownames=varargin{2};
0243       <span class="keyword">case</span> <span class="string">'err'</span>,
0244          errcalc=varargin{2};
0245       <span class="keyword">case</span> <span class="string">'syn'</span>,
0246          synth=varargin{2};
0247       <span class="keyword">case</span> <span class="string">'lsq'</span>,
0248          lsq=varargin{2};     
0249       <span class="keyword">otherwise</span>,
0250          error([<span class="string">'Can''t understand property:'</span> varargin{1}]);
0251     <span class="keyword">end</span>;
0252     varargin([1 2])=[]; 
0253   <span class="keyword">else</span>  
0254     <span class="keyword">switch</span> k,
0255       <span class="keyword">case</span> 1,
0256         dt=varargin{1};
0257       <span class="keyword">case</span> 2,
0258         stime=varargin{1};
0259       <span class="keyword">case</span> 3,
0260         lat=varargin{1};
0261       <span class="keyword">case</span> 4,
0262         ray=varargin{1};
0263       <span class="keyword">otherwise</span>
0264         error(<span class="string">'Too many input parameters'</span>);
0265      <span class="keyword">end</span>;
0266      varargin(1)=[];
0267   <span class="keyword">end</span>;
0268   k=k+1;
0269 <span class="keyword">end</span>;
0270  
0271 [inn,inm]=size(xin);
0272 <span class="keyword">if</span> ~(inn==1 | inm==1), error(<span class="string">'Input time series is not a vector'</span>); <span class="keyword">end</span>;
0273 
0274 xin=xin(:); <span class="comment">% makes xin a column vector</span>
0275 nobs=length(xin);
0276 
0277 <span class="keyword">if</span> strcmp(lsq(1:3),<span class="string">'bes'</span>),  <span class="comment">% Set matrix method if auto-choice.</span>
0278  <span class="keyword">if</span> nobs&gt;10000,
0279     lsq=<span class="string">'normal'</span>;
0280  <span class="keyword">else</span>
0281     lsq=<span class="string">'direct'</span>;
0282  <span class="keyword">end</span>;
0283 <span class="keyword">end</span>;
0284  
0285 <span class="keyword">if</span> nobs*dt&gt; 18.6*365.25*24,  <span class="comment">% Long time series</span>
0286   longseries=1; ltype=<span class="string">'full'</span>;
0287 <span class="keyword">else</span>
0288   longseries=0; ltype=<span class="string">'nodal'</span>;
0289 <span class="keyword">end</span>;
0290                 
0291 nobsu=nobs-rem(nobs-1,2);<span class="comment">% makes series odd to give a center point</span>
0292 
0293 t=dt*([1:nobs]'-ceil(nobsu/2));  <span class="comment">% Time vector for entire time series,</span>
0294                                  <span class="comment">% centered at series midpoint.</span>
0295 
0296 <span class="keyword">if</span> ~isempty(stime),
0297   centraltime=stime+floor(nobsu./2)./24.0*dt;
0298 <span class="keyword">else</span>
0299   centraltime=[];
0300 <span class="keyword">end</span>;
0301 
0302 <span class="comment">% -------Get the frequencies to use in the harmonic analysis-----------</span>
0303 
0304 [nameu,fu,ju,namei,fi,jinf,jref]=<a href="#_sub1" class="code" title="subfunction [nameu,fu,ju,namei,fi,jinf,jref]=constituents(minres,constit,">constituents</a>(ray/(dt*nobsu),constitnames,<span class="keyword">...</span>
0305                                            shallownames,inf.iname,inf.irefname,centraltime);
0306 
0307 mu=length(fu); <span class="comment">% # base frequencies</span>
0308 mi=length(fi); <span class="comment">% # inferred</span>
0309 
0310 <span class="comment">% Find the good data points (here I assume that in a complex time</span>
0311 <span class="comment">% series, if u is bad, so is v).</span>
0312 
0313 gd=find(isfinite(xin(1:nobsu)));
0314 ngood=length(gd);
0315 fprintf(<span class="string">'   Points used: %d of %d\n'</span>,ngood,nobs)
0316 
0317 
0318 
0319 <span class="comment">%----------------------------------------------------------------------</span>
0320 <span class="comment">% Now solve for the secular trend plus the analysis. Instead of solving</span>
0321 <span class="comment">% for + and - frequencies using exp(i*f*t), I use sines and cosines to</span>
0322 <span class="comment">% keep tc real.  If the input series is real, than this will</span>
0323 <span class="comment">% automatically use real-only computation (faster). However, for the analysis,</span>
0324 <span class="comment">% it's handy to get the + and - frequencies ('ap' and 'am'), and so</span>
0325 <span class="comment">% that's what we do afterwards.</span>
0326 
0327 <span class="comment">% The basic code solves the matrix problem Ac=x+errors where the functions to</span>
0328 <span class="comment">% use in the fit fill up the A matrix, which is of size (number points)x(number</span>
0329 <span class="comment">% constituents). This can get very, very large for long time series, and</span>
0330 <span class="comment">% for this the more complex block processing algorithm was added. It should</span>
0331 <span class="comment">% give identical results (up to roundoff error)</span>
0332 
0333 <span class="keyword">if</span> strcmp(lsq(1:3),<span class="string">'dir'</span>),
0334 
0335   <span class="keyword">if</span> secular(1:3)==<span class="string">'lin'</span>,
0336     tc=[ones(length(t),1) cos((2*pi)*t*fu') sin((2*pi)*t*fu') t*(2/dt/nobsu)];
0337   <span class="keyword">else</span>
0338     tc=[ones(length(t),1) cos((2*pi)*t*fu') sin((2*pi)*t*fu') ];
0339   <span class="keyword">end</span>;
0340   
0341   coef=tc(gd,:)\xin(gd);
0342 
0343   z0=coef(1);
0344   ap=(coef(2:(1+mu))-i*coef((2+mu):(1+2*mu)))/2;  <span class="comment">% a+ amplitudes</span>
0345   am=(coef(2:(1+mu))+i*coef((2+mu):(1+2*mu)))/2;  <span class="comment">% a- amplitudes</span>
0346   <span class="keyword">if</span> secular(1:3)==<span class="string">'lin'</span>,
0347     dz0=coef(end);
0348   <span class="keyword">else</span>
0349     dz0=0;
0350   <span class="keyword">end</span>;    
0351   xout=tc*coef;  <span class="comment">% This is the time series synthesized from the analysis</span>
0352 
0353 <span class="keyword">else</span>  <span class="comment">% More complicated code required for long time series when memory may be</span>
0354       <span class="comment">% a problem. Modified from code submitted by Derek Goring (NIWA Chrischurch)</span>
0355       
0356       <span class="comment">% Basically the normal equations are formed (rather than using Matlab's \</span>
0357       <span class="comment">% algorithm for least squares); this can be done by adding up subblocks</span>
0358       <span class="comment">% of data. Notice how the code is messier, and we have to recalculate everything</span>
0359       <span class="comment">% to get the original fit.</span>
0360 
0361   nsub=5000;  <span class="comment">% Block length - doesn't matter really but should be small enough to</span>
0362               <span class="comment">% get allocated quickly</span>
0363   <span class="keyword">if</span> secular(1:3)==<span class="string">'lin'</span>,
0364     lhs=zeros(mu*2+2,mu*2+2); rhs=zeros(mu*2+2,1);
0365     <span class="keyword">for</span> j1=1:nsub:ngood
0366       j2=min(j1 + nsub - 1,ngood);
0367       E=[ones(j2-j1+1,1) cos((2*pi)*t(gd(j1:j2))*fu') sin((2*pi)*t(gd(j1:j2))*fu') t(gd(j1:j2))*(2/dt/nobsu)];
0368       rhs=rhs + E'*xin(gd(j1:j2));
0369       lhs=lhs + E'*E;
0370     <span class="keyword">end</span>;
0371   <span class="keyword">else</span>  
0372     lhs=zeros(mu*2+1,mu*2+1); rhs=zeros(mu*2+1,1);
0373     <span class="keyword">for</span> j1=1:nsub:ngood
0374       j2=min(j1 + nsub - 1,ngood);
0375       E=[ones(j2-j1+1,1) cos((2*pi)*t(gd(j1:j2))*fu') sin((2*pi)*t(gd(j1:j2))*fu')];
0376       rhs=rhs + E'*xin(gd(j1:j2));
0377       lhs=lhs + E'*E;
0378     <span class="keyword">end</span>;
0379   <span class="keyword">end</span>;
0380     
0381   coef=lhs\rhs;
0382   
0383   z0=coef(1);
0384   ap=(coef(2:(1+mu))-i*coef((2+mu):(1+2*mu)))/2;  <span class="comment">% a+ amplitudes</span>
0385   am=(coef(2:(1+mu))+i*coef((2+mu):(1+2*mu)))/2;  <span class="comment">% a- amplitudes</span>
0386   <span class="keyword">if</span> secular(1:3)==<span class="string">'lin'</span>,
0387     dz0=coef(end);
0388   <span class="keyword">else</span>
0389     dz0=0;
0390   <span class="keyword">end</span>; 
0391   
0392   xout=xin; <span class="comment">% Copies over NaN</span>
0393   <span class="keyword">if</span> secular(1:3)==<span class="string">'lin'</span>,
0394     <span class="keyword">for</span> j1=1:nsub:nobs
0395       j2=min(j1 + nsub - 1,nobs);
0396       E=[ones(j2-j1+1,1) cos((2*pi)*t(j1:j2)*fu') sin((2*pi)*t(j1:j2)*fu') t(j1:j2)*(2/dt/nobsu)];
0397       xout(j1:j2)=E*coef;
0398     <span class="keyword">end</span>;
0399   <span class="keyword">else</span>  
0400     <span class="keyword">for</span> j1=1:nsub:nobs
0401       j2=min(j1 + nsub - 1,nobs);
0402       E=[ones(j2-j1+1,1) cos((2*pi)*t(j1:j2)*fu') sin((2*pi)*t(j1:j2)*fu')];
0403       xout(j1:j2)=E*coef;
0404     <span class="keyword">end</span>;
0405   <span class="keyword">end</span>;
0406 
0407 <span class="keyword">end</span>;
0408 
0409    
0410  
0411 <span class="comment">%----------------------------------------------------------------------</span>
0412 <span class="comment">% Check variance explained (but do this with the original fit).</span>
0413 
0414 xres=xin-xout; <span class="comment">% and the residuals!</span>
0415 
0416 <span class="keyword">if</span> isreal(xin),    <span class="comment">% Real time series</span>
0417   varx=cov(xin(gd));varxp=cov(xout(gd));varxr=cov(xres(gd));
0418   fprintf(<span class="string">'   percent of var residual after lsqfit/var original: %5.2f %%\n'</span>,100*(varxr/varx));  
0419 <span class="keyword">else</span>               <span class="comment">% Complex time series</span>
0420   varx=cov(real(xin(gd)));varxp=cov(real(xout(gd)));varxr=cov(real(xres(gd)));
0421   fprintf(<span class="string">'   percent of X var residual after lsqfit/var original: %5.2f %%\n'</span>,100*(varxr/varx));
0422 
0423   vary=cov(imag(xin(gd)));varyp=cov(imag(xout(gd)));varyr=cov(imag(xres(gd)));
0424   fprintf(<span class="string">'   percent of Y var residual after lsqfit/var original: %5.2f %%\n'</span>,100*(varyr/vary));
0425 <span class="keyword">end</span>;
0426 
0427 
0428 <span class="comment">%---------- Correct for prefiltering-----------------------------------</span>
0429 
0430 corrfac=interp1(corr_fs,corr_fac,fu);
0431 <span class="comment">% To stop things blowing up!</span>
0432 corrfac(corrfac&gt;100 | corrfac &lt;.01 | isnan(corrfac))=1;
0433 
0434 ap=ap.*corrfac;
0435 am=am.*conj(corrfac);
0436 
0437 <span class="comment">%---------------Nodal Corrections--------------------------------------</span>
0438 <span class="comment">% Generate nodal corrections and calculate phase relative to Greenwich.</span>
0439 <span class="comment">% Note that this is a slightly weird way to do the nodal corrections,</span>
0440 <span class="comment">% but is 'traditional'.  The &quot;right&quot; way would be to change the basis</span>
0441 <span class="comment">% functions used in the least-squares fit above.</span>
0442 
0443 <span class="keyword">if</span> ~isempty(lat) &amp; ~isempty(stime),   <span class="comment">% Time and latitude</span>
0444 
0445   <span class="comment">% Get nodal corrections at midpoint time.</span>
0446   [v,u,f]=<a href="t_vuf.html" class="code" title="function [v,u,f]=t_vuf(ltype,ctime,ju,lat);">t_vuf</a>(ltype,centraltime,[ju;jinf],lat);                                       
0447 
0448   vu=(v+u)*360; <span class="comment">% total phase correction (degrees)</span>
0449   nodcor=[<span class="string">'Greenwich phase computed with nodal corrections applied to amplitude \n and phase relative to center time'</span>];    
0450 <span class="keyword">elseif</span> ~isempty(stime),    <span class="comment">% Time only</span>
0451   <span class="comment">% Get nodal corrections at midpoint time</span>
0452   [v,u,f]=<a href="t_vuf.html" class="code" title="function [v,u,f]=t_vuf(ltype,ctime,ju,lat);">t_vuf</a>(ltype,centraltime,[ju;jinf]);                                           
0453   vu=(v+u)*360; <span class="comment">% total phase correction (degrees)</span>
0454   nodcor=[<span class="string">'Greenwich phase computed, no nodal corrections'</span>];                                   
0455 <span class="keyword">else</span>   <span class="comment">% No time, no latitude</span>
0456   vu=zeros(length(ju)+length(jinf),1);                                             
0457   f=ones(length(ju)+length(jinf),1);                                               
0458    nodcor=[<span class="string">'Phases at central time'</span>];                                               
0459 <span class="keyword">end</span>                                                               
0460 fprintf([<span class="string">'   '</span>,nodcor,<span class="string">'\n'</span>]);                                                   
0461 
0462 
0463 <span class="comment">%---------------Inference Corrections----------------------------------</span>
0464 <span class="comment">% Once again, the &quot;right&quot; way to do this would be to change the basis</span>
0465 <span class="comment">% functions.</span>
0466 ii=find(isfinite(jref));
0467 <span class="keyword">if</span> ii,
0468   fprintf(<span class="string">'   Do inference corrections\n'</span>);
0469   snarg=nobsu*pi*(fi(ii)   -fu(jref(ii)) )*dt;
0470   scarg=sin(snarg)./snarg;
0471  
0472   <span class="keyword">if</span> size(inf.amprat,2)==1,    <span class="comment">% For real time series</span>
0473     pearg=     2*pi*(vu(mu+ii)-vu(jref(ii))+inf.ph(ii))/360;
0474     pcfac=inf.amprat(ii).*f(mu+ii)./f(jref(ii)).*exp(i*pearg);
0475     pcorr=1+pcfac.*scarg;
0476     mcfac=conj(pcfac);
0477     mcorr=conj(pcorr);
0478   <span class="keyword">else</span>                          <span class="comment">% For complex time series</span>
0479     pearg=     2*pi*(vu(mu+ii)-vu(jref(ii))+inf.ph(ii,1))/360;
0480     pcfac=inf.amprat(ii,1).*f(mu+ii)./f(jref(ii)).*exp(i*pearg);
0481     pcorr=1+pcfac.*scarg;
0482     mearg=    -2*pi*(vu(mu+ii)-vu(jref(ii))+inf.ph(ii,2))/360;
0483     mcfac=inf.amprat(ii,2).*f(mu+ii)./f(jref(ii)).*exp(i*mearg);
0484     mcorr=1+mcfac.*scarg;
0485   <span class="keyword">end</span>;
0486     
0487   ap(jref(ii))=ap(jref(ii))./pcorr;   <span class="comment">% Changes to existing constituents</span>
0488   ap=[ap;ap(jref(ii)).*pcfac];        <span class="comment">% Inferred constituents</span>
0489 
0490   am(jref(ii))=am(jref(ii))./mcorr;
0491   am=[am;am(jref(ii)).*mcfac];
0492 
0493   fu=[fu;fi(ii)];
0494   nameu=[nameu;namei(ii,:)];
0495 <span class="keyword">end</span>;
0496 
0497 <span class="comment">% --------------Error Bar Calculations---------------------------------</span>
0498 <span class="comment">%</span>
0499 <span class="comment">% Error bar calcs involve two steps:</span>
0500 <span class="comment">%      1) Estimate the uncertainties in the analyzed amplitude</span>
0501 <span class="comment">%         for both + and - frequencies (i.e., in 'ap' and 'am').</span>
0502 <span class="comment">%         A simple way of doing this is to take the variance of the</span>
0503 <span class="comment">%         original time series and divide it into the amount appearing</span>
0504 <span class="comment">%         in the bandwidth of the analysis (approximately 1/length).</span>
0505 <span class="comment">%         A more sophisticated way is to assume &quot;locally white&quot;</span>
0506 <span class="comment">%         noise in the vicinity of, e.g., the diurnal consistuents.</span>
0507 <span class="comment">%         This takes into account slopes in the continuum spectrum.</span>
0508 <span class="comment">%</span>
0509 <span class="comment">%      2) Transform those uncertainties into ones suitable for ellipse</span>
0510 <span class="comment">%         parameters (axis lengths, angles). This can be done</span>
0511 <span class="comment">%         analytically for large signal-to-noise ratios. However, the</span>
0512 <span class="comment">%         transformation is non-linear at lows SNR, say, less than 10</span>
0513 <span class="comment">%         or so.</span>
0514 <span class="comment">%</span>
0515 
0516 xr=<a href="#_sub2" class="code" title="subfunction y=fixgaps(x);">fixgaps</a>(xres); <span class="comment">% Fill in &quot;internal&quot; NaNs with linearly interpolated</span>
0517                   <span class="comment">% values so we can fft things.</span>
0518 nreal=1;
0519 
0520 <span class="keyword">if</span> strmatch(errcalc(2:end),<span class="string">'boot'</span>),
0521   fprintf(<span class="string">'   Using nonlinear bootstrapped error estimates\n'</span>);
0522   
0523   <span class="comment">% &quot;noise&quot; matrices are created with the right covariance structure</span>
0524   <span class="comment">% to add to the analyzed components to create 'nreal' REPLICATES.</span>
0525   <span class="comment">%</span>
0526 
0527   nreal=300;             <span class="comment">% Create noise matrices</span>
0528   [NP,NM]=<a href="#_sub4" class="code" title="subfunction [NP,NM]=noise_realizations(xres,fu,dt,nreal,errcalc);">noise_realizations</a>(xr(isfinite(xr)),fu,dt,nreal,errcalc);
0529       
0530   <span class="comment">% All replicates are then transformed (nonlinearly) into ellipse</span>
0531   <span class="comment">% parameters.  The computed error bars are then based on the std</span>
0532   <span class="comment">% dev of the replicates.</span>
0533 
0534   AP=ap(:,ones(1,nreal))+NP;        <span class="comment">% Add to analysis (first column</span>
0535   AM=am(:,ones(1,nreal))+NM;        <span class="comment">% of NM,NP=0 so first column of</span>
0536                                     <span class="comment">% AP/M holds ap/m).</span>
0537   epsp=angle(AP)*180/pi;            <span class="comment">% Angle/magnitude form:</span>
0538   epsm=angle(AM)*180/pi;
0539   ap=abs(AP);
0540   am=abs(AM);
0541 <span class="keyword">elseif</span> strmatch(errcalc,<span class="string">'linear'</span>),
0542   fprintf(<span class="string">'   Using linearized error estimates\n'</span>);
0543   <span class="comment">%</span>
0544   <span class="comment">% Uncertainties in analyzed amplitudes are computed in different</span>
0545   <span class="comment">% spectral bands. Real and imaginary parts of the residual time series</span>
0546   <span class="comment">% are treated separately (no cross-covariance is assumed).</span>
0547   <span class="comment">%</span>
0548   <span class="comment">% Noise estimates are then determined from a linear analysis of errors,</span>
0549   <span class="comment">% assuming that everything is uncorrelated. This is OK for scalar time</span>
0550   <span class="comment">% series but can fail for vector time series if the noise is not</span>
0551   <span class="comment">% isotropic.</span>
0552   
0553   [ercx,eicx]=<a href="#_sub5" class="code" title="subfunction [ercx,eicx]=noise_stats(xres,fu,dt);">noise_stats</a>(xr(isfinite(xr)),fu,dt);
0554   <span class="comment">% Note - here we assume that the error in the cos and sin terms is</span>
0555   <span class="comment">% equal, and equal to total power in the encompassing frequency bin.</span>
0556   <span class="comment">% It seems like there should be a factor of 2 here somewhere but it</span>
0557   <span class="comment">% only works this way! &lt;shrug&gt;</span>
0558   [emaj,emin,einc,epha]=<a href="#_sub7" class="code" title="subfunction [emaj,emin,einc,epha]=errell(cxi,sxi,ercx,ersx,ercy,ersy)">errell</a>(ap+am,i*(ap-am),ercx,ercx,eicx,eicx);
0559 
0560   epsp=angle(ap)*180/pi;
0561   epsm=angle(am)*180/pi;
0562   ap=abs(ap);
0563   am=abs(am);
0564 <span class="keyword">else</span>
0565   error([<span class="string">'Unrecognized type of error analysis: '''</span> errcalc <span class="string">''' specified!'</span>]);
0566 <span class="keyword">end</span>;
0567 
0568 <span class="comment">%-----Convert complex amplitudes to standard ellipse parameters--------</span>
0569 
0570 aap=ap./f(:,ones(1,nreal));    <span class="comment">% Apply nodal corrections and</span>
0571 aam=am./f(:,ones(1,nreal));    <span class="comment">% compute ellipse parameters.</span>
0572 
0573 fmaj=aap+aam;                   <span class="comment">% major axis</span>
0574 fmin=aap-aam;                   <span class="comment">% minor axis</span>
0575 
0576 gp=mod( vu(:,ones(1,nreal))-epsp ,360); <span class="comment">% pos. Greenwich phase in deg.</span>
0577 gm=mod( vu(:,ones(1,nreal))+epsm ,360); <span class="comment">% neg. Greenwich phase in deg.</span>
0578 
0579 finc= (epsp+epsm)/2;
0580 finc(:,1)=mod( finc(:,1),180 ); <span class="comment">% Ellipse inclination in degrees</span>
0581                 <span class="comment">% (mod 180 to prevent ambiguity, i.e.,</span>
0582                 <span class="comment">% we always ref. against northern</span>
0583                 <span class="comment">% semi-major axis.</span>
0584     
0585 finc=<a href="#_sub3" class="code" title="subfunction ain=cluster(ain,clusang);">cluster</a>(finc,180);     <span class="comment">% Cluster angles around the 'true'</span>
0586                                 <span class="comment">% angle to avoid 360 degree wraps.</span>
0587 
0588 pha=mod( gp+finc ,360);     <span class="comment">% Greenwich phase in degrees.</span>
0589 
0590 pha=<a href="#_sub3" class="code" title="subfunction ain=cluster(ain,clusang);">cluster</a>(pha,360);        <span class="comment">% Cluster angles around the 'true' angle</span>
0591                 <span class="comment">% to avoid 360 degree wraps.</span>
0592 
0593 <span class="comment">%----------------Generate 95% CI---------------------------------------</span>
0594 <span class="comment">%% For bootstrapped errors, we now compute limits of the distribution.</span>
0595 <span class="keyword">if</span> strmatch(errcalc(2:end),<span class="string">'boot'</span>),
0596      <span class="comment">%% std dev-based estimates.</span>
0597      <span class="comment">% The 95% CI are computed from the sigmas</span>
0598      <span class="comment">% by a 1.96 fudge factor (infinite degrees of freedom).</span>
0599      <span class="comment">% emaj=1.96*std(fmaj,0,2);</span>
0600      <span class="comment">% emin=1.96*std(fmin,0,2);</span>
0601      <span class="comment">% einc=1.96*std(finc,0,2);</span>
0602      <span class="comment">% epha=1.96*std(pha ,0,2);</span>
0603      <span class="comment">%% Median-absolute-deviation (MAD) based estimates.</span>
0604      <span class="comment">% (possibly more stable?)</span>
0605       emaj=median(abs(fmaj-median(fmaj,2)*ones(1,nreal)),2)/.6375*1.96;
0606       emin=median(abs(fmin-median(fmin,2)*ones(1,nreal)),2)/.6375*1.96;
0607       einc=median(abs(finc-median(finc,2)*ones(1,nreal)),2)/.6375*1.96;
0608       epha=median(abs( pha-median( pha,2)*ones(1,nreal)),2)/.6375*1.96;
0609 <span class="keyword">else</span>
0610    <span class="comment">% In the linear analysis, the 95% CI are computed from the sigmas</span>
0611    <span class="comment">% by this fudge factor (infinite degrees of freedom).</span>
0612    emaj=1.96*emaj;
0613    emin=1.96*emin;
0614    einc=1.96*einc;
0615    epha=1.96*epha;
0616 <span class="keyword">end</span>;
0617                   
0618 <span class="keyword">if</span> isreal(xin),
0619     tidecon=[fmaj(:,1),emaj,pha(:,1),epha];
0620 <span class="keyword">else</span>
0621     tidecon=[fmaj(:,1),emaj,fmin(:,1),emin, finc(:,1),einc,pha(:,1),epha];
0622 <span class="keyword">end</span>;
0623 
0624 <span class="comment">% Sort results by frequency (needed if anything has been inferred since</span>
0625 <span class="comment">% these are stuck at the end of the list by code above).</span>
0626 <span class="keyword">if</span> any(isfinite(jref)),
0627  [fu,I]=sort(fu);
0628  nameu=nameu(I,:);
0629  tidecon=tidecon(I,:);
0630 <span class="keyword">end</span>;
0631 
0632 snr=(tidecon(:,1)./tidecon(:,2)).^2;  <span class="comment">% signal to noise ratio</span>
0633 
0634 <span class="comment">%--------Generate a 'prediction' using significant constituents----------</span>
0635 xoutOLD=xout;
0636 <span class="keyword">if</span> synth&gt;=0,
0637  <span class="keyword">if</span> ~isempty(lat) &amp; ~isempty(stime),
0638    fprintf(<span class="string">'   Generating prediction with nodal corrections, SNR is %f\n'</span>,synth);
0639    xout=<a href="t_predic.html" class="code" title="function yout=t_predic(tim,varargin);">t_predic</a>(stime+[0:nobs-1]*dt/24.0,nameu,fu,tidecon,<span class="string">'lat'</span>,lat,<span class="string">'synth'</span>,synth,<span class="string">'anal'</span>,ltype);
0640  <span class="keyword">elseif</span> ~isempty(stime), 
0641    fprintf(<span class="string">'   Generating prediction without nodal corrections, SNR is %f\n'</span>,synth);
0642    xout=<a href="t_predic.html" class="code" title="function yout=t_predic(tim,varargin);">t_predic</a>(stime+[0:nobs-1]*dt/24.0,nameu,fu,tidecon,<span class="string">'synth'</span>,synth,<span class="string">'anal'</span>,ltype);
0643  <span class="keyword">else</span>
0644    fprintf(<span class="string">'   Generating prediction without nodal corrections, SNR is %f\n'</span>,synth);
0645    xout=<a href="t_predic.html" class="code" title="function yout=t_predic(tim,varargin);">t_predic</a>(t/24.0,nameu,fu,tidecon,<span class="string">'synth'</span>,synth,<span class="string">'anal'</span>,ltype);
0646  <span class="keyword">end</span>;
0647 <span class="keyword">else</span>
0648  fprintf(<span class="string">'   Returning fitted prediction\n'</span>);
0649 <span class="keyword">end</span>;
0650 
0651 <span class="comment">%----------------------------------------------------------------------</span>
0652 <span class="comment">% Check variance explained (but now do this with the synthesized fit).</span>
0653 xres=xin(:)-xout(:); <span class="comment">% and the residuals!</span>
0654 
0655 <span class="comment">%error;</span>
0656 
0657 <span class="keyword">if</span> isreal(xin),    <span class="comment">% Real time series</span>
0658   varx=cov(xin(gd));varxp=cov(xout(gd));varxr=cov(xres(gd));
0659   fprintf(<span class="string">'   percent of var residual after synthesis/var original: %5.2f %%\n'</span>,100*(varxr/varx));  
0660 <span class="keyword">else</span>               <span class="comment">% Complex time series</span>
0661   varx=cov(real(xin(gd)));varxp=cov(real(xout(gd)));varxr=cov(real(xres(gd)));
0662   fprintf(<span class="string">'   percent of X var residual after synthesis/var original: %5.2f %%\n'</span>,100*(varxr/varx));
0663 
0664   vary=cov(imag(xin(gd)));varyp=cov(imag(xout(gd)));varyr=cov(imag(xres(gd)));
0665   fprintf(<span class="string">'   percent of Y var residual after synthesis/var original: %5.2f %%\n'</span>,100*(varyr/vary));
0666 <span class="keyword">end</span>;
0667 
0668 
0669 <span class="comment">%-----------------Output results---------------------------------------</span>
0670 
0671 <span class="keyword">if</span> fid&gt;1,
0672  fprintf(fid,<span class="string">'\n%s\n'</span>,[<span class="string">'file name: '</span>,filen]);
0673 <span class="keyword">elseif</span> fid==1,
0674  fprintf(fid,<span class="string">'-----------------------------------\n'</span>);
0675 <span class="keyword">end</span>
0676 
0677 <span class="keyword">if</span> fid&gt;0,
0678   fprintf(fid,<span class="string">'date: %s\n'</span>,date);
0679   fprintf(fid,<span class="string">'nobs = %d,  ngood = %d,  record length (days) = %.2f\n'</span>,nobs,ngood,length(xin)*dt/24);
0680   <span class="keyword">if</span> ~isempty(stime); fprintf(fid,<span class="string">'%s\n'</span>,[<span class="string">'start time: '</span>,datestr(stime)]); <span class="keyword">end</span>
0681   fprintf(fid,<span class="string">'rayleigh criterion = %.1f\n'</span>,ray);
0682   fprintf(fid,<span class="string">'%s\n'</span>,nodcor);
0683 <span class="comment">%  fprintf(fid,'\n     coefficients from least squares fit of x\n');</span>
0684 <span class="comment">%  fprintf(fid,'\n tide    freq        |a+|       err_a+      |a-|       err_a-\n');</span>
0685 <span class="comment">%  for k=1:length(fu);</span>
0686 <span class="comment">%    if ap(k)&gt;eap(k) | am(k)&gt;eam(k), fprintf('*'); else fprintf(' '); end;</span>
0687 <span class="comment">%    fprintf(fid,'%s  %8.5f  %9.4f  %9.4f  %9.4f  %9.4f\n',nameu(k,:),fu(k),ap(k),eap(k),am(k),eam(k));</span>
0688 <span class="comment">%  end</span>
0689   fprintf(fid,<span class="string">'\nx0= %.3g, x trend= %.3g\n'</span>,real(z0),real(dz0));
0690   fprintf(fid,[<span class="string">'\nvar(x)= '</span>,num2str(varx),<span class="string">'   var(xp)= '</span>,num2str(varxp),<span class="string">'   var(xres)= '</span>,num2str(varxr) <span class="string">'\n'</span>]);
0691   fprintf(fid,<span class="string">'percent var predicted/var original= %.1f %%\n'</span>,100*varxp/varx);
0692 
0693   <span class="keyword">if</span> isreal(xin)
0694     fprintf(fid,<span class="string">'\n     tidal amplitude and phase with 95%% CI estimates\n'</span>);
0695     fprintf(fid,<span class="string">'\ntide   freq       amp     amp_err    pha    pha_err     snr\n'</span>);
0696     <span class="keyword">for</span> k=1:length(fu);
0697       <span class="keyword">if</span> snr(k)&gt;synth, fprintf(fid,<span class="string">'*'</span>); <span class="keyword">else</span> fprintf(fid,<span class="string">' '</span>); <span class="keyword">end</span>;
0698       fprintf(fid,<span class="string">'%s %9.7f %9.4f %8.3f %8.2f %8.2f %8.2g\n'</span>,nameu(k,:),fu(k),tidecon(k,:),snr(k));
0699     <span class="keyword">end</span>
0700   <span class="keyword">else</span>
0701     fprintf(fid,<span class="string">'\ny0= %.3g, x trend= %.3g\n'</span>,imag(z0),imag(dz0));
0702     fprintf(fid,[<span class="string">'\nvar(y)= '</span>,num2str(vary),<span class="string">'    var(yp)= '</span>,num2str(varyp),<span class="string">'  var(yres)= '</span>,num2str(varyr) <span class="string">'\n'</span>]);
0703     fprintf(fid,<span class="string">'percent var predicted/var original= %.1f %%\n'</span>,100*varyp/vary);
0704     fprintf(fid,<span class="string">'\n%s\n'</span>,[<span class="string">'ellipse parameters with 95%% CI estimates'</span>]);
0705     fprintf(fid,<span class="string">'\n%s\n'</span>,[<span class="string">'tide   freq      major  emaj    minor   emin     inc    einc     pha    epha      snr'</span>]);
0706     <span class="keyword">for</span> k=1:length(fu);
0707       <span class="keyword">if</span> snr(k)&gt;synth, fprintf(fid,<span class="string">'*'</span>); <span class="keyword">else</span> fprintf(fid,<span class="string">' '</span>); <span class="keyword">end</span>;
0708       fprintf(fid,<span class="string">'%s %9.7f %6.3f %7.3f %7.3f %6.2f %8.2f %6.2f %8.2f %6.2f %6.2g\n'</span>,<span class="keyword">...</span>
0709     nameu(k,:),fu(k),tidecon(k,:),snr(k));
0710     <span class="keyword">end</span>
0711     fprintf(fid,[<span class="string">'\ntotal var= '</span>,num2str(varx+vary),<span class="string">'   pred var= '</span>,num2str(varxp+varyp) <span class="string">'\n'</span>]);
0712     fprintf(fid,<span class="string">'percent total var predicted/var original= %.1f %%\n\n'</span>,100*(varxp+varyp)/(varx+vary));
0713   <span class="keyword">end</span>
0714 
0715   <span class="keyword">if</span> fid~=1, st=fclose(fid); <span class="keyword">end</span>
0716 <span class="keyword">end</span>;
0717 
0718 xout=reshape(xout,inn,inm);
0719 <span class="keyword">switch</span> nargout,
0720   <span class="keyword">case</span> {0,3,4}
0721   <span class="keyword">case</span> {1}
0722    nameu = struct(<span class="string">'name'</span>,nameu,<span class="string">'freq'</span>,fu,<span class="string">'tidecon'</span>,tidecon,<span class="string">'type'</span>,ltype);
0723   <span class="keyword">case</span> {2}   
0724    nameu = struct(<span class="string">'name'</span>,nameu,<span class="string">'freq'</span>,fu,<span class="string">'tidecon'</span>,tidecon,<span class="string">'type'</span>,ltype);
0725    fu=xout;
0726 <span class="keyword">end</span>;
0727    
0728 <span class="comment">%----------------------------------------------------------------------</span>
0729 <a name="_sub1" href="#_subfunctions" class="code">function [nameu,fu,ju,namei,fi,jinf,jref]=constituents(minres,constit,</a><span class="keyword">...</span>
0730                                      shallow,infname,infref,centraltime);
0731 <span class="comment">% [name,freq,kmpr]=constituents(minres,infname) loads tidal constituent</span>
0732 <span class="comment">% table (containing 146 constituents), then picks out only the '</span>
0733 <span class="comment">% resolvable' frequencies (i.e. those that are MINRES apart), base on</span>
0734 <span class="comment">% the comparisons in the third column of constituents.dat. Only</span>
0735 <span class="comment">% frequencies in the 'standard' set of 69 frequencies are actually used.</span>
0736 <span class="comment">% Also return the indices of constituents to be inferred.</span>
0737 
0738 <span class="comment">% If we have the mat-file, read it in, otherwise create it and read</span>
0739 <span class="comment">% it in!</span>
0740 
0741 <span class="comment">% R Pawlowicz 9/1/01</span>
0742 <span class="comment">% Version 1.0</span>
0743 <span class="comment">%</span>
0744 <span class="comment">%    19/1/02 - typo fixed (thanks to  Zhigang Xu)</span>
0745 
0746 <span class="comment">% Compute frequencies from astronomical considerations.</span>
0747 
0748 <span class="keyword">if</span> minres&gt;1/(18.6*365.25*24),                       <span class="comment">% Choose only resolveable pairs for short</span>
0749   [const,sat,cshallow]=<a href="t_getconsts.html" class="code" title="function [const,sat,shallow]=t_getconsts(ctime);">t_getconsts</a>(centraltime);    <span class="comment">% Time series</span>
0750   ju=find(const.df&gt;=minres);
0751 <span class="keyword">else</span>                                                <span class="comment">% Choose them all if &gt; 18.6 years.</span>
0752   [const,sat,cshallow]=t_get18consts(centraltime);
0753   ju=[2:length(const.freq)]';  <span class="comment">% Skip Z0</span>
0754   <span class="keyword">for</span> ff=1:2,                  <span class="comment">% loop twice to make sure of neightbouring pairs</span>
0755     jck=find(diff(const.freq(ju))&lt;minres);
0756     <span class="keyword">if</span> (length(jck)&gt;0)
0757        jrm=jck;
0758        jrm=jrm+(abs(const.doodsonamp(ju(jck+1)))&lt;abs(const.doodsonamp(ju(jck))));
0759        disp([<span class="string">'  Warning! Following constituent pairs violate Rayleigh criterion'</span>]);
0760        <span class="keyword">for</span> ick=1:length(jck);
0761      disp([<span class="string">'     '</span>,const.name(ju(jck(ick)),:),<span class="string">' vs '</span>,const.name(ju(jck(ick)+1),:) <span class="string">' - not using '</span>,const.name(ju(jrm(ick)),:)]);
0762        <span class="keyword">end</span>;
0763        ju(jrm)=[];
0764     <span class="keyword">end</span>
0765   <span class="keyword">end</span>;
0766 <span class="keyword">end</span>;
0767   
0768 <span class="keyword">if</span> ~isempty(constit),     <span class="comment">% Selected if constituents are specified in input.</span>
0769   ju=[];
0770   <span class="keyword">for</span> k=1:size(constit,1),
0771    j1=strmatch(constit(k,:),const.name);
0772    <span class="keyword">if</span> isempty(j1),
0773      disp([<span class="string">'Can''t recognize name '</span> constit(k,:) <span class="string">' for forced search'</span>]);
0774    <span class="keyword">elseif</span> j1==1,
0775      disp([<span class="string">'*************************************************************************'</span>]);
0776      disp([<span class="string">'Z0 specification ignored - for non-tidal offsets see ''secular'' property'</span>]);
0777      disp([<span class="string">'*************************************************************************'</span>]);
0778    <span class="keyword">else</span>  
0779      ju=[ju;j1];
0780    <span class="keyword">end</span>;
0781   <span class="keyword">end</span>;
0782   [dum,II]=sort(const.freq(ju)); <span class="comment">% sort in ascending order of frequency.</span>
0783   ju=ju(II);
0784 <span class="keyword">end</span>;
0785 
0786 
0787 disp([<span class="string">'   number of standard constituents used: '</span>,int2str(length(ju))])
0788 
0789 <span class="keyword">if</span> ~isempty(shallow),          <span class="comment">% Add explictly selected shallow water constituents.</span>
0790  <span class="keyword">for</span> k=1:size(shallow,1),
0791    j1=strmatch(shallow(k,:),const.name);
0792    <span class="keyword">if</span> isempty(j1),
0793      disp([<span class="string">'Can''t recognize name '</span> shallow(k,:) <span class="string">' for forced search'</span>]);
0794    <span class="keyword">else</span>
0795      <span class="keyword">if</span> isnan(const.ishallow(j1)),
0796        disp([shallow(k,:) <span class="string">' Not a shallow-water constituent'</span>]);
0797      <span class="keyword">end</span>;
0798      disp([<span class="string">'   Forced fit to '</span> shallow(k,:)]);
0799      ju=[ju;j1];
0800    <span class="keyword">end</span>;
0801  <span class="keyword">end</span>;
0802  
0803 <span class="keyword">end</span>;
0804       
0805 nameu=const.name(ju,:);
0806 fu=const.freq(ju);
0807 
0808 
0809 <span class="comment">% Check if neighboring chosen constituents violate Rayleigh criteria.</span>
0810 jck=find(diff(fu)&lt;minres);
0811 <span class="keyword">if</span> (length(jck)&gt;0)
0812    disp([<span class="string">'  Warning! Following constituent pairs violate Rayleigh criterion'</span>]);
0813    <span class="keyword">for</span> ick=1:length(jck);
0814    disp([<span class="string">'     '</span>,nameu(jck(ick),:),<span class="string">'  '</span>,nameu(jck(ick)+1,:)]);
0815    <span class="keyword">end</span>;
0816 <span class="keyword">end</span>
0817 
0818 <span class="comment">% For inference, add in list of components to be inferred.</span>
0819 
0820 fi=[];namei=[];jinf=[];jref=[];
0821 <span class="keyword">if</span> ~isempty(infname),
0822   fi=zeros(size(infname,1),1);
0823   namei=zeros(size(infname,1),4);
0824   jinf=zeros(size(infname,1),1)+NaN;
0825   jref=zeros(size(infname,1),1)+NaN;
0826 
0827   <span class="keyword">for</span> k=1:size(infname,1),
0828    j1=strmatch(infname(k,:),const.name);
0829    <span class="keyword">if</span> isempty(j1),
0830      disp([<span class="string">'Can''t recognize name'</span> infname(k,:) <span class="string">' for inference'</span>]);
0831    <span class="keyword">else</span>
0832     jinf(k)=j1;
0833     fi(k)=const.freq(j1);
0834     namei(k,:)=const.name(j1,:);
0835     j1=strmatch(infref(k,:),nameu);
0836     <span class="keyword">if</span> isempty(j1),
0837       disp([<span class="string">'Can''t recognize name '</span> infref(k,:) <span class="string">' for as a reference for inference'</span>]);
0838     <span class="keyword">else</span>
0839       jref(k)=j1;
0840       fprintf([<span class="string">'   Inference of '</span> namei(k,:) <span class="string">' using '</span> nameu(j1,:) <span class="string">'\n'</span>]);
0841     <span class="keyword">end</span>;
0842    <span class="keyword">end</span>;
0843   <span class="keyword">end</span>;    
0844   jinf(isnan(jref))=NaN;
0845 <span class="keyword">end</span>;
0846 
0847 <span class="comment">%----------------------------------------------------------------------</span>
0848 <a name="_sub2" href="#_subfunctions" class="code">function y=fixgaps(x);</a>
0849 <span class="comment">% FIXGAPS: Linearly interpolates gaps in a time series</span>
0850 <span class="comment">% YOUT=FIXGAPS(YIN) linearly interpolates over NaN in the input time</span>
0851 <span class="comment">% series (may be complex), but ignores trailing and leading NaNs.</span>
0852 
0853 <span class="comment">% R. Pawlowicz 11/6/99</span>
0854 <span class="comment">% Version 1.0</span>
0855 
0856 y=x;
0857 
0858 bd=isnan(x);
0859 gd=find(~bd);
0860 
0861 bd([1:(min(gd)-1) (max(gd)+1):end])=0;
0862 
0863 
0864 y(bd)=interp1(gd,x(gd),find(bd)); 
0865 
0866 
0867 <span class="comment">%----------------------------------------------------------------------</span>
0868 <a name="_sub3" href="#_subfunctions" class="code">function ain=cluster(ain,clusang);</a>
0869 <span class="comment">% CLUSTER: Clusters angles in rows around the angles in the first</span>
0870 <span class="comment">% column. CLUSANG is the allowable ambiguity (usually 360 degrees but</span>
0871 <span class="comment">% sometimes 180).</span>
0872 
0873 ii=(ain-ain(:,ones(1,size(ain,2))))&gt;clusang/2;
0874 ain(ii)=ain(ii)-clusang;
0875 ii=(ain-ain(:,ones(1,size(ain,2))))&lt;-clusang/2;
0876 ain(ii)=ain(ii)+clusang;
0877 
0878 
0879 <span class="comment">%----------------------------------------------------------------------</span>
0880 <a name="_sub4" href="#_subfunctions" class="code">function [NP,NM]=noise_realizations(xres,fu,dt,nreal,errcalc);</a>
0881 <span class="comment">% NOISE_REALIZATIONS: Generates matrices of noise (with correct</span>
0882 <span class="comment">% cross-correlation structure) for bootstrap analysis.</span>
0883 <span class="comment">%</span>
0884 
0885 <span class="comment">% R. Pawlowicz 11/10/00</span>
0886 <span class="comment">% Version 1.0</span>
0887 
0888 <span class="keyword">if</span> strmatch(errcalc,<span class="string">'cboot'</span>),
0889   [fband,Pxrave,Pxiave,Pxcave]=<a href="#_sub6" class="code" title="subfunction [fband,Pxrave,Pxiave,Pxcave]=residual_spectrum(xres,fu,dt)">residual_spectrum</a>(xres,fu,dt);
0890   
0891   Pxcave=zeros(size(Pxcave));  <span class="comment">%% For comparison with other technique!</span>
0892   <span class="comment">%fprintf('**** Assuming no covariance between u and v errors!*******\n');</span>
0893 
0894 <span class="keyword">elseif</span> strmatch(errcalc,<span class="string">'wboot'</span>),
0895   fband=[0 .5];
0896   nx=length(xres);
0897   A=cov(real(xres),imag(xres))/nx;
0898   Pxrave=A(1,1);Pxiave=A(2,2);Pxcave=A(1,2);
0899 <span class="keyword">else</span>
0900   error([<span class="string">'Unrecognized type of bootstap analysis specified: '''</span> errcalc <span class="string">''''</span>]);
0901 <span class="keyword">end</span>;
0902   
0903 nfband=size(fband,1);
0904 
0905 Mat=zeros(4,4,nfband);
0906 <span class="keyword">for</span> k=1:nfband,
0907 
0908   <span class="comment">% The B matrix represents the covariance matrix for the vector</span>
0909   <span class="comment">% [Re{ap} Im{ap} Re{am} Im{am}]' where Re{} and Im{} are real and</span>
0910   <span class="comment">% imaginary parts, and ap/m represent the complex constituent</span>
0911   <span class="comment">% amplitudes for positive and negative frequencies when the input</span>
0912   <span class="comment">% is bivariate white noise. For a flat residual spectrum this works</span>
0913   <span class="comment">% fine.</span>
0914  
0915   <span class="comment">% This is adapted here for &quot;locally white&quot; conditions, but I'm still</span>
0916   <span class="comment">% not sure how to handle a complex sxy, so this is set to zero</span>
0917   <span class="comment">% right now.</span>
0918   
0919   p=(Pxrave(k)+Pxiave(k))/2;
0920   d=(Pxrave(k)-Pxiave(k))/2;
0921   sxy=Pxcave(k);
0922   
0923   B=[p    0   d   sxy;
0924      0    p  sxy  -d;
0925      d   sxy  p    0
0926      sxy -d   0    p];
0927 
0928   <span class="comment">% Compute the transformation matrix that takes uncorrelated white</span>
0929   <span class="comment">% noise and makes noise with the same statistical structure as the</span>
0930   <span class="comment">% Fourier transformed noise.</span>
0931   [V,D]=eig(B);
0932   Mat(:,:,k)=V*diag(sqrt(diag(D)));
0933 <span class="keyword">end</span>;
0934 
0935 <span class="comment">% Generate realizations for the different analyzed constituents.</span>
0936 
0937 N=zeros(4,nreal);
0938 NM=zeros(length(fu),nreal);
0939 NP=NM;
0940 <span class="keyword">for</span> k=1:length(fu);
0941   l=find(fu(k)&gt;fband(:,1) &amp; fu(k)&lt;fband(:,2));
0942   N=[zeros(4,1),Mat(:,:,l)*randn(4,nreal-1)];
0943   NP(k,:)=N(1,:)+i*N(2,:);
0944   NM(k,:)=N(3,:)+i*N(4,:);
0945 <span class="keyword">end</span>;
0946 
0947 <span class="comment">%----------------------------------------------------------------------</span>
0948 <a name="_sub5" href="#_subfunctions" class="code">function [ercx,eicx]=noise_stats(xres,fu,dt);</a>
0949 <span class="comment">% NOISE_STATS: Computes statistics of residual energy for all</span>
0950 <span class="comment">% constituents (ignoring any cross-correlations between real and</span>
0951 <span class="comment">% imaginary parts).</span>
0952 
0953 <span class="comment">% S. Lentz  10/28/99</span>
0954 <span class="comment">% R. Pawlowicz 11/1/00</span>
0955 <span class="comment">% Version 1.0</span>
0956 
0957 [fband,Pxrave,Pxiave,Pxcave]=<a href="#_sub6" class="code" title="subfunction [fband,Pxrave,Pxiave,Pxcave]=residual_spectrum(xres,fu,dt)">residual_spectrum</a>(xres,fu,dt);
0958 nfband=size(fband,1);
0959 mu=length(fu);
0960 
0961 <span class="comment">% Get the statistics for each component.</span>
0962 ercx=zeros(mu,1);
0963 eicx=zeros(mu,1);
0964 <span class="keyword">for</span> k1=1:nfband;
0965    k=find(fu&gt;=fband(k1,1) &amp; fu&lt;=fband(k1,2));
0966    ercx(k)=sqrt(Pxrave(k1));
0967    eicx(k)=sqrt(Pxiave(k1));
0968 <span class="keyword">end</span>
0969 
0970 <span class="comment">%----------------------------------------------------------------------</span>
0971 <a name="_sub6" href="#_subfunctions" class="code">function [fband,Pxrave,Pxiave,Pxcave]=residual_spectrum(xres,fu,dt)</a>
0972 <span class="comment">% RESIDUAL_SPECTRUM: Computes statistics from an input spectrum over</span>
0973 <span class="comment">% a number of bands, returning the band limits and the estimates for</span>
0974 <span class="comment">% power spectra for real and imaginary parts and the cross-spectrum.</span>
0975 <span class="comment">%</span>
0976 <span class="comment">% Mean values of the noise spectrum are computed for the following</span>
0977 <span class="comment">% 8 frequency bands defined by their center frequency and band width:</span>
0978 <span class="comment">% M0 +.1 cpd; M1 +-.2 cpd; M2 +-.2 cpd; M3 +-.2 cpd; M4 +-.2 cpd;</span>
0979 <span class="comment">% M5 +-.2 cpd; M6 +-.21 cpd; M7 (.26-.29 cpd); and M8 (.30-.50 cpd).</span>
0980 
0981 <span class="comment">% S. Lentz  10/28/99</span>
0982 <span class="comment">% R. Pawlowicz 11/1/00</span>
0983 <span class="comment">% Version 1.0</span>
0984 
0985 <span class="comment">% Define frequency bands for spectral averaging.</span>
0986 fband =[.00010 .00417;
0987         .03192 .04859;
0988         .07218 .08884;
0989         .11243 .12910;
0990         .15269 .16936;
0991         .19295 .20961;
0992         .23320 .25100;
0993         .26000 .29000;
0994         .30000 .50000];
0995 
0996 <span class="comment">% If we have a sampling interval&gt; 1 hour, we might have to get</span>
0997 <span class="comment">% rid of some bins.</span>
0998 <span class="comment">%fband(fband(:,1)&gt;1/(2*dt),:)=[];</span>
0999 
1000 nfband=size(fband,1);
1001 nx=length(xres);
1002 
1003 <span class="comment">% Spectral estimate (takes real time series only).</span>
1004 
1005 
1006 <span class="comment">% Matlab has changed their spectral estimator functions</span>
1007 <span class="comment">% To match the old code, I have to divide by 2*dt. This is because</span>
1008 <span class="comment">%</span>
1009 <span class="comment">%  PSD*dt  is two-sided spectrum in units of power per hertz.</span>
1010 <span class="comment">%</span>
1011 <span class="comment">%  PWELCH is the one-sided spectrum in power per hertz</span>
1012 <span class="comment">%</span>
1013 <span class="comment">%  So PWELCH/2 = PSD*dt</span>
1014 
1015 
1016 <span class="comment">%[Pxr,fx]=psd(real(xres),nx,1/dt); % Call to SIGNAL PROCESSING TOOLBOX - see note in t_readme. If you have an error here you are probably missing this toolbox</span>
1017 <span class="comment">%[Pxi,fx]=psd(imag(xres),nx,1/dt); % Call to SIGNAL PROCESSING TOOLBOX - see note in t_readme.</span>
1018 <span class="comment">%[Pxc,fx]=csd(real(xres),imag(xres),nx,1/dt); % Call to SIGNAL PROCESSING TOOLBOX - see note in t_readme.</span>
1019 
1020 
1021 [Pxr,fx]=pwelch(real(xres),hanning(nx),ceil(nx/2),nx,1/dt); <span class="comment">% Call to SIGNAL PROCESSING TOOLBOX - see note in t_readme. If you have an error here you are probably missing this toolbox</span>
1022 Pxr=Pxr/2/dt;
1023 [Pxi,fx]=pwelch(imag(xres),hanning(nx),ceil(nx/2),nx,1/dt); <span class="comment">% Call to SIGNAL PROCESSING TOOLBOX - see note in t_readme.</span>
1024 Pxi=Pxi/2/dt;
1025 [Pxc,fx]=cpsd(real(xres),imag(xres),[],[],nx,1/dt); <span class="comment">% Call to SIGNAL PROCESSING TOOLBOX - see note in t_readme.</span>
1026 Pxc=Pxc/2/dt;
1027 
1028 df=fx(3)-fx(2);
1029 Pxr(round(fu./df)+1)=NaN ; <span class="comment">% Sets Px=NaN in bins close to analyzed frequencies</span>
1030 Pxi(round(fu./df)+1)=NaN ; <span class="comment">% (to prevent leakage problems?).</span>
1031 Pxc(round(fu./df)+1)=NaN ; 
1032 
1033 Pxrave=zeros(nfband,1);
1034 Pxiave=zeros(nfband,1);
1035 Pxcave=zeros(nfband,1);
1036 <span class="comment">% Loop downwards in frequency through bands (cures short time series</span>
1037 <span class="comment">% problem with no data in lowest band).</span>
1038 <span class="comment">%</span>
1039 <span class="comment">% Divide by nx to get power per frequency bin, and multiply by 2</span>
1040 <span class="comment">% to account for positive and negative frequencies.</span>
1041 <span class="comment">%</span>
1042 <span class="keyword">for</span> k=nfband:-1:1,
1043    jband=find(fx&gt;=fband(k,1) &amp; fx&lt;=fband(k,2) &amp; isfinite(Pxr));
1044    <span class="keyword">if</span> any(jband),
1045      Pxrave(k)=mean(Pxr(jband))*2/nx;
1046      Pxiave(k)=mean(Pxi(jband))*2/nx;
1047      Pxcave(k)=mean(Pxc(jband))*2/nx;
1048    <span class="keyword">elseif</span> k&lt;nfband,
1049      Pxrave(k)=Pxrave(k+1);   <span class="comment">% Low frequency bin might not have any points...</span>
1050      Pxiave(k)=Pxiave(k+1);   
1051      Pxcave(k)=Pxcave(k+1);   
1052    <span class="keyword">end</span>;
1053 <span class="keyword">end</span>
1054  
1055 
1056 <span class="comment">%----------------------------------------------------------------------</span>
1057 <a name="_sub7" href="#_subfunctions" class="code">function [emaj,emin,einc,epha]=errell(cxi,sxi,ercx,ersx,ercy,ersy)</a>
1058 <span class="comment">% [emaj,emin,einc,epha]=errell(cx,sx,cy,sy,ercx,ersx,ercy,ersy) computes</span>
1059 <span class="comment">% the uncertainities in the ellipse parameters based on the</span>
1060 <span class="comment">% uncertainities in the least square fit cos,sin coefficients.</span>
1061 <span class="comment">%</span>
1062 <span class="comment">%  INPUT:  cx,sx=cos,sin coefficients for x</span>
1063 <span class="comment">%          cy,sy=cos,sin coefficients for y</span>
1064 <span class="comment">%          ercx,ersx=errors in x cos,sin coefficients</span>
1065 <span class="comment">%          ercy,ersy=errors in y cos,sin coefficients</span>
1066 <span class="comment">%</span>
1067 <span class="comment">%  OUTPUT: emaj=major axis error</span>
1068 <span class="comment">%          emin=minor axis error</span>
1069 <span class="comment">%          einc=inclination error (deg)</span>
1070 <span class="comment">%          epha=pha error (deg)</span>
1071 
1072 <span class="comment">% based on linear error propagation, with errors in the coefficients</span>
1073 <span class="comment">% cx,sx,cy,sy uncorrelated.</span>
1074 
1075 <span class="comment">% B. Beardsley  1/15/99; 1/20/99</span>
1076 <span class="comment">% Version 1.0</span>
1077 
1078 r2d=180./pi;
1079 cx=real(cxi(:));sx=real(sxi(:));cy=imag(cxi(:));sy=imag(sxi(:));
1080 ercx=ercx(:);ersx=ersx(:);ercy=ercy(:);ersy=ersy(:);
1081 
1082 rp=.5.*sqrt((cx+sy).^2+(cy-sx).^2);
1083 rm=.5.*sqrt((cx-sy).^2+(cy+sx).^2);
1084 ercx2=ercx.^2;ersx2=ersx.^2;
1085 ercy2=ercy.^2;ersy2=ersy.^2;
1086 
1087 <span class="comment">% major axis error</span>
1088 ex=(cx+sy)./rp;
1089 fx=(cx-sy)./rm;
1090 gx=(sx-cy)./rp;
1091 hx=(sx+cy)./rm;
1092 dcx2=(.25.*(ex+fx)).^2;
1093 dsx2=(.25.*(gx+hx)).^2;
1094 dcy2=(.25.*(hx-gx)).^2;
1095 dsy2=(.25.*(ex-fx)).^2;
1096 emaj=sqrt(dcx2.*ercx2+dsx2.*ersx2+dcy2.*ercy2+dsy2.*ersy2);
1097 
1098 <span class="comment">% minor axis error</span>
1099 dcx2=(.25.*(ex-fx)).^2;
1100 dsx2=(.25.*(gx-hx)).^2;
1101 dcy2=(.25.*(hx+gx)).^2;
1102 dsy2=(.25.*(ex+fx)).^2;
1103 emin=sqrt(dcx2.*ercx2+dsx2.*ersx2+dcy2.*ercy2+dsy2.*ersy2);
1104 
1105 <span class="comment">% inclination error</span>
1106 rn=2.*(cx.*cy+sx.*sy);
1107 rd=cx.^2+sx.^2-(cy.^2+sy.^2);
1108 den=rn.^2+rd.^2;
1109 dcx2=((rd.*cy-rn.*cx)./den).^2;
1110 dsx2=((rd.*sy-rn.*sx)./den).^2;
1111 dcy2=((rd.*cx+rn.*cy)./den).^2;
1112 dsy2=((rd.*sx+rn.*sy)./den).^2;
1113 einc=r2d.*sqrt(dcx2.*ercx2+dsx2.*ersx2+dcy2.*ercy2+dsy2.*ersy2);
1114 
1115 <span class="comment">% phase error</span>
1116 rn=2.*(cx.*sx+cy.*sy);
1117 rd=cx.^2-sx.^2+cy.^2-sy.^2;
1118 den=rn.^2+rd.^2;
1119 dcx2=((rd.*sx-rn.*cx)./den).^2;
1120 dsx2=((rd.*cx+rn.*sx)./den).^2;
1121 dcy2=((rd.*sy-rn.*cy)./den).^2;
1122 dsy2=((rd.*cy+rn.*sy)./den).^2;
1123 epha=r2d.*sqrt(dcx2.*ercx2+dsx2.*ersx2+dcy2.*ercy2+dsy2.*ersy2);
1124 
1125 
1126 
1127 
1128</pre></div>
<hr><address>Generated on Thu 15-Sep-2016 12:42:46 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>